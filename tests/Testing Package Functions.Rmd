
#Running through MoT Road Safety Package R

### Libraries required to build a package

```{r}
library(devtools)
library(roxygen2)
library(testthat)
library(knitr)
```

### Libraries required in the package or for teh data analysis

```{r}
## these are the libraries that are require

library(sf)
library(ghroute)
router(osm.file = "~/Documents/University of Auckland/COMPSCI 791 Research Project/mot_road_safety_project/osm")
library(leaflet)
library(mapview)
library(readxl)
library(dplyr)


```


### Loading the data

```{r}



data("jtw_usual_res_geo_sample_data")
data("jtw_work_geo_sample_data")
data("sa2_clipped_geo_akl")
data("cas_data_sample_2018")

```
#### i. Loading the full dataset

```{r}

## Read journey to work Data 2018
jtw_data <- read.csv("~/Documents/University of Auckland/COMPSCI 791 Research Project/data/2018-census-main-means-of-travel-to-work-by-statistical-area.csv", fileEncoding="UTF-8-BOM")

## SA2 to MB mapping provided by StatsNZ
key <- read_xlsx("~/Documents/University of Auckland/COMPSCI 791 Research Project/data/Stats NZ Geographic Key.xlsx", 
           sheet = "Geographic Key")

## correcting Territorial auth desc name
names(key)[8] <- "Territorial_auth_desc"

## grouping by SA2 and territorial auth district to remove duplicates
key_2 <- key[, c(3,8)] %>% 
  group_by(`Statistical area 2 code (2018 areas)`, Territorial_auth_desc) %>% 
  summarise(n = n()) %>% 
  mutate(`Statistical area 2 code (2018 areas)` = 
           as.integer(`Statistical area 2 code (2018 areas)`))


## only interested in Auckland where the mode of transport is driving
## and SA2 residence is not the same as SA2 workplace 
jtw_driving_akl <- jtw_data[(jtw_data$Drive_a_company_car_truck_or_van > 0 | 
  jtw_data$Drive_a_private_car_truck_or_van > 0), ] %>% 
  left_join(key_2[, 1:2], by = c("SA2_code_usual_residence_address" = 
                                   "Statistical area 2 code (2018 areas)")) %>%
  filter(Territorial_auth_desc == "Auckland" & 
           SA2_code_usual_residence_address != SA2_code_workplace_address)

## CAS data
cas_data <- readRDS("~/Documents/University of Auckland/COMPSCI 791 Research Project/data/Crash_Analysis_System_(CAS)_data.rds")

## create a new column called non_injury_crash
cas_data$non_injury_crash <- ifelse(cas_data$crashSeverity == 'Non-Injury Crash', 1, 0)

table(cas_data$crashSeverity)

## total crashes
cas_data$total <- cas_data$fatalCount + cas_data$minorInjuryCount + cas_data$seriousInjuryCount + cas_data$non_injury_crash

cas_data_akl_proj <- st_as_sf(cas_data[cas_data$region == 'Auckland Region',], coords = c("X", "Y"), crs = 2193)

cas_data_akl_geo <- st_transform(cas_data_akl_proj, crs = 4326)

##filtering the data to serious and fatal crashes in 2018 around the Auckland Region
cas_data_akl_2018_geo <-  cas_data_akl_geo[(cas_data_akl_geo$crashYear == 2018 & cas_data_akl_geo$region == "Auckland Region"), ]

```



### 1. Get routes function

The purpose of get routes function is for user to provide a vector of source 
and destination lat/lon points and returns it as an sf dataframe. 
If no route is found then the function will return an empty sf object value 
in the sf dataframe

```{r}

test_get_routes <-  
get_routes(c(sf::st_coordinates(jtw_usual_res_geo_sample_data)[, "Y"],-36.85576),
           c(sf::st_coordinates(jtw_usual_res_geo_sample_data)[, "X"],174.8324),
           c(sf::st_coordinates(jtw_work_geo_sample_data)[, "Y"],41.2709),
           c(sf::st_coordinates(jtw_work_geo_sample_data)[, "X"],173.1476))

test_get_routes

leaflet() %>% 
  addTiles() %>%
  addPolygons(data = sa2_clipped_geo_akl[372, ], color = 'red', fillOpacity = .2) %>% 
  addPolylines(data = st_geometry(test_get_routes)[1]) %>% 
  addPolylines(data = st_geometry(test_get_routes)[2], color = 'green') %>% 
  addPolylines(data = st_geometry(test_get_routes)[3], color = 'black') 


##plot routes option parameter, default = FALSE 

# Simon advised that plot should be separate function to pass the routes dataframe

#confirm plot is outside the lower level function

#add class or methods for plotting (s3 class suggested by simon)

```

### 2. Get intersections function

The purpose of this function is to provide the indices of

```{r}

test_get_route_intersects <- get_route_intersects(test_get_routes, sa2_clipped_geo_akl)

test_get_route_intersects

test_get_route_intersects_inverse <-  get_route_intersects(test_get_routes, 
                                                           sa2_clipped_geo_akl, 
                                                           inverse = TRUE)

test_get_route_intersects_inverse

leaflet() %>% 
  addTiles() %>%
  addPolygons(data = sa2_clipped_geo_akl[test_get_route_intersects[[1]], ], color = 'red') %>% 
  addPolylines(data = test_get_routes[1, ])


leaflet() %>% 
  addTiles() %>%
  addPolygons(data = sa2_clipped_geo_akl[372, ], color = 'red', fillOpacity = .2) %>% 
  addPolylines(data = st_geometry(test_get_routes)[1]) %>% 
  addPolylines(data = st_geometry(test_get_routes)[2], color = 'green') %>% 
  addPolylines(data = st_geometry(test_get_routes)[3], color = 'orange') 
  

  

```

### 3. Get distance travelled function

```{r}

get_dist_travelled_test <- get_dist_travel(sa2_clipped_geo_akl,
                                           test_get_routes)

mapview(get_dist_travelled_test, zcol = 'total_dist', 
        layer.name = "total distance travelled")

head(get_dist_travelled_test)

leaflet() %>% 
  addTiles() %>%
  addPolygons(data = get_dist_travelled_test[!is.na(get_dist_travelled_test$weight), ], opacity = .1,  color = 'blue') %>% 
  addPolylines(data = st_geometry(test_get_routes)[1], color = 'green') %>% 
  addPolylines(data = st_geometry(test_get_routes)[2], color = 'red') %>% 
  addPolylines(data = st_geometry(test_get_routes)[3], color = 'black') 


```

### 4. Get Risk function

calculate the number of risk 

```{r}

test_get_risk <- get_risk(st_coordinates(cas_data_sample_2018)[, "Y"],
         st_coordinates(cas_data_sample_2018)[, "X"],
         cas_data_sample_2018$seriousInjuryCount,
         sa2_clipped_geo_akl)


test_get_risk_2 <- get_risk(st_coordinates(cas_data_sample_2018)[, "Y"],
         st_coordinates(cas_data_sample_2018)[, "X"],
         cas_data_sample_2018$seriousInjuryCount,
         get_dist_travelled_test)

mapview(test_get_risk, zcol = 'total_crash_weight', 
        layer.name = "total crash weight")

head(test_get_risk)

```

### 5. Risky Routes function

How risk is each route based on crashes that occurred within 5 meters from the 
route

```{r}


test_route_risk <- route_risk(test_get_routes, st_coordinates(cas_data_sample_2018)[, "Y"],
         st_coordinates(cas_data_sample_2018)[, "X"],
         cas_data_sample_2018$seriousInjuryCount) 


sum(cas_data_sample_2018$seriousInjuryCount)
sum(test_route_risk$total_crash_weight)


test_route_risk


leaflet() %>% 
  addTiles() %>%
  addPolylines(data = st_geometry(test_route_risk)[1:3], color = 'blue',
               weight = test_route_risk$total_crash_weight)

#add buffer to the crash points
#assumption ot treat all crash as the in

#add a parameter for cas distance

#shriv - visualisation of all crashes that is within 5 meters or any number the routes

#simon - candidate routes is what we have, we don't have the exact source and destination and we need to apply the probability 
#- what is the probability that the route produced is correct


```

### Discussion

A discussion on coordinate reference systems is a complex topic in and of itself, 
and for the purposes of this module, we summarize it as follows: 

A geographic CRS is round and based on angular units of degrees (lat/lng), 
whereas a projected CRS is flat and has linear units (meters or feet). 

Many functions in {sf} that make calculations on data expect a projected CRS, 
and can return inaccurate results if an object in a geographic CRS is used. 

This is a fascinating topic with lots written about it! For more reading see 
this Esri blog, the Data Carpentry geospatial lesson, and 
the online Geocomputation with R book.

URL:https://www.r4wrds.com/intro/m_intro_mapmaking.html#reading-spatial-data


Next Steps:

1. find out which crashes is not close to the routes (shriv), visualise it and qualitative analysis (create an inverse of risky routes). Also take into consideration the time that crash occurred - filter during commute time only. 

2. find out metric biases with a lot of assumptions implemented and compare to the methodology by trafficalmr

3. implementing the functions with MB data and applying random sampling to increase route accuracy

4. create an s3 generic on sf class to plot or visualise the data

Simon:
- take into account direction of the roads and where crash location occurred

Shriv:
- focus on `home to work` route rather than work to home (messy)
- rationalising work to home routes and identify underlying issues
- impact the one way streets and associate crashes on that 




#########################################################


### Visualization

```{r}

mapview::mapview(st_geometry(test_route_risk))


mapview(test_get_risk, zcol = "total_crash_weight", alpha = 0.5)


mapview(test_get_risk, zcol = "total_crash_weight",
        alpha.regions  = 0.4)

mapview(test_get_risk


names(test_get_risk)

```



### Scratch

```{r}


sf::st_
get_routes()

ghroute::router(osm.file = "C:\\Users\\kathl\\Documents\\University of Auckland\\Mprof Data Science\\COMPSCI 791 Industry Research Project - MoT Trafficalmr Package in R\\MoT_road_safety_proj\\osm\\new-zealand-latest.osm.pbf")


ghroute::router(osm.file = "new-zealand-latest.osm.pbf")

#working ok now
test2 <- get_routes(sf::st_coordinates(jtw_usual_res_geo_sample_data)[, "Y"],
           sf::st_coordinates(jtw_usual_res_geo_sample_data)[, "X"],
           sf::st_coordinates(jtw_work_geo_sample_data)[, "Y"],
           sf::st_coordinates(jtw_work_geo_sample_data)[, "X"])


#testing no routes
test_no_routes_error <-  
get_routes(c(sf::st_coordinates(jtw_usual_res_geo_sample_data)[, "Y"],-36.85576),
           c(sf::st_coordinates(jtw_usual_res_geo_sample_data)[, "X"],174.8324),
           c(sf::st_coordinates(jtw_work_geo_sample_data)[, "Y"],41.2709),
           c(sf::st_coordinates(jtw_work_geo_sample_data)[, "X"],173.1476))

(test_no_routes_error, recursive = FALSE)



st_point(tryCatch(ghroute::route(-36.85576, 174.8324, 41.2709, 173.1476), error = function(e) NA))
  
  
test3 = rbind(test2, st_as_sf(st_sfc(NULL, crs = 4326)))

class(test3)

st_linestring(st_sfc(NULL, crs = 4326))



length(test_no_routes_error)

test_no_routes_error[[1]]

lapply(lengt(i),)

##################################
test <-  ghroute::route(sf::st_coordinates(jtw_usual_res_geo_sample_data)[1, "Y"],
           sf::st_coordinates(jtw_usual_res_geo_sample_data)[1, "X"],
           sf::st_coordinates(jtw_work_geo_sample_data)[1, "Y"],
           sf::st_coordinates(jtw_work_geo_sample_data)[1, "X"])


st_geom(test[[1]][[1]][ ,2:1])


sf_value_transform <- function(x){ st_as_sf(
  
  if(any(is.na(x))){
    st_sfc(x, crs = 4326)}
  else {
    st_sfc(st_linestring(x), crs = 4326)})
  }


sf_value_transform(test_no_routes_error[[4]])

sf_value_transform, test_no_routes_error)

do.call(rbind, lapply(test_no_routes_error, sf_value_transform))


final_result <- map_dfr(test_no_routes_error, function(x){ st_as_sf(
  
  if(any(is.na(x))){
    st_sfc(x, crs = 4326)}
  else {
    st_sfc(st_linestring(x), crs = 4326)})
  })

class(final_result)

final_result

jgc <- function()
{
  gc()
  .jcall("java/lang/System", method = "gc")
} 

jgc()

```



